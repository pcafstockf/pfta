/**
 * This module contains the Change operations generated by this packages Diff algorithm.
 * It is separate from the diff module because we want to be able to apply the Changes at some later time, perhaps even (de)serialize as JSON for patching in another process.
 */
import {ObjPropType} from './discover';
import {jsonES6Replacer, jsonES6Reviver, stringHashCode} from './util';


/**
 * Specifies something within a "container".
 * NOTE: A value can be anything, but the "path" to it (by definition) is a sequence of containers (array, object, set, map).
 */
export interface PathSegment {
	/**
	 * The type of the container
	 */
	typeOf: string;
	/**
	 * The reference (aka property, key, index, hash) that the container uses to access the value.
	 */
	segment: ObjPropType;
}

/**
 * Internal function to create one of a small set of known containers (array, set, map, object).
 */
function createContainer(typeOf: string) {
	switch (typeOf) {
		case 'array':
			return [];
		case 'object':
			return {};
		case 'set':
			return new Set<any>();
		case 'map':
			return new Map<any, any>();
		default:
			throw new TypeError('Unknown target type');
	}
}

/**
 * Internal function to walk down the specified path of an object graph to the 'container' of the last thing specified by the path (somewhat like the path to a directory containing a file).
 * @param root  The top of the object graph
 * @param path  The path to walk
 * @param materialize   Whether to create missing containers to get to the end of the path.
 * @returns The last container in the path (the parent of whatever the path points to).
 */
function leafContainer(root: any, path: PathSegment[], materialize: boolean) {
	let s;
	let tmp;
	let target = root;
	let l = path.length - 1;
	// Walk the container path.
	for (let i = 0; i < l; i++) {
		s = path[i];
		switch (s.typeOf) {
			case 'array':
				if (!Array.isArray(target))
					throw new TypeError('Invalid path segment');
				tmp = target[s.segment];
				if ((!tmp) && materialize) {
					tmp = createContainer(path[i + 1].typeOf);
					target[s.segment] = tmp;
				}
				break;
			case 'object':
				if (!target)
					throw new TypeError('Invalid path segment');
				tmp = target[s.segment];
				if ((!tmp) && materialize) {
					tmp = createContainer(path[i + 1].typeOf);
					target[s.segment] = tmp;
				}
				break;
			case 'set':
				if (!(target instanceof Set))
					throw new TypeError('Invalid path segment');
				if (typeof s.segment === 'string') {
					let h = parseInt(s.segment.substring(1), 10);
					tmp = Array.from(target).find(v => stringHashCode(JSON.stringify(v)) === h);
				}
				else
					tmp = Array.from(target)[s.segment];
				if ((!tmp) && materialize) {
					tmp = createContainer(path[i + 1].typeOf);
					target.add(tmp);
				}
				break;
			case 'map':
				if (!(target instanceof Map))
					throw new TypeError('Invalid path segment');
				tmp = target.get(s.segment);
				if ((!tmp) && materialize) {
					tmp = createContainer(path[i + 1].typeOf);
					target.set(s.segment, tmp);
				}
				break;
			default:
				throw new TypeError('Unknown target type');
		}
		if (!tmp)
			return undefined;
		target = tmp;
	}
	return target;
}

/**
 * Internal function to set the value of whatever 'path' points to within the specified object graph.
 * @param root  The target object graph
 * @param path  Think file path.
 * @param value The value to set
 * @param materialize   Whether non-existent containers along the path should be created.
 * @returns the previous value found at 'path'
 */
function setContainerElement(root: any, path: PathSegment[], value: any, materialize?: boolean): any {
	if (path.length === 0)
		return value;
	let prevValue;
	let target = leafContainer(root, path, !!materialize);
	if (target) {
		let i;
		let s = path[path.length - 1];
		switch (s.typeOf) {
			case 'array':
				if (!Array.isArray(target))
					throw new TypeError('Invalid path segment');
				// Warning:  Poor use of Magic... A negative property value for an array element signifies "insert" as opposed to "set".
				i = Math.abs(<number>s.segment);
				if (<number>s.segment < 0)
					i = i - 1;
				prevValue = target[i];
				if (<number>s.segment < 0) {
					if (i > target.length)
						target[i] = value;
					else
						target.splice(i, 0, value);
				}
				else
					target[i] = value;
				break;
			case 'object':
				if (!target)
					throw new TypeError('Invalid path segment');
				prevValue = target[s.segment];
				target[s.segment] = value;
				break;
			case 'set':
				if (!(target instanceof Set))
					throw new TypeError('Invalid path segment');
				if (target.has(value))
					prevValue = value;
				target.add(value);
				break;
			case 'map':
				if (!(target instanceof Map))
					throw new TypeError('Invalid path segment');
				prevValue = target.get(s.segment);
				target.set(s.segment, value);
				break;
			default:
				throw new TypeError('Unknown target type');
		}
	}
	return prevValue;
}

/**
 * Removes the element at the specified path from it's container.
 * @param root  The target object graph
 * @param path  Think file path.
 * @returns The value that was located at 'path' (if any) within the object graph.
 */
function deleteContainerElement(root: any, path: PathSegment[]): any {
	if (path.length === 0)
		return undefined;
	let value;
	let target = leafContainer(root, path, false);
	if (target) {
		let i;
		let s = path[path.length - 1];
		switch (s.typeOf) {
			case 'array':
				if (!Array.isArray(target))
					throw new TypeError('Invalid path segment');
				// Warning:  Poor use of Magic... A negative property value for an array element signifies "insert" as opposed to "set".
				// A delete is always a splice, but we need to compensate for the reduce by one aspect (refer to the 'array' block in @see setContainerElement for clarification)
				i = Math.abs(<number>s.segment);
				if (<number>s.segment < 0)
					i = i - 1;
				value = target[i];
				target.splice(i, 1);
				break;
			case 'object':
				if (!target)
					throw new TypeError('Invalid path segment');
				value = target[s.segment];
				delete target[s.segment];
				break;
			case 'set':
				if (!(target instanceof Set))
					throw new TypeError('Invalid path segment');
				if (typeof s.segment === 'string') {
					let h = parseInt(s.segment.substring(1), 10);
					value = Array.from(target).find(v => stringHashCode(JSON.stringify(v)) === h);
				}
				else
					value = Array.from(target)[s.segment];
				if (!target.delete(value))
					value = undefined;
				break;
			case 'map':
				if (!(target instanceof Map))
					throw new TypeError('Invalid path segment');
				value = target.get(s.segment);
				target.delete(s.segment);
				break;
			default:
				throw new TypeError('Unknown target type');
		}
	}
	return value;
}

/**
 * Returned from a @see Change.apply operation to allow you to undo the application of the Change.
 */
export interface UnDo {
	/**
	 * Undo the previously applied Change.
	 */
	undo(): ReDo;
}

/**
 * Specialization of UnDo for Remove and Edit type Changes.
 */
export interface UnDoWithPrev extends UnDo {
	readonly previousValue: any;
}

/**
 * Returned from a @see UnDo.undo operation, to allow you to re-apply the Change.
 */
export interface ReDo {
	/**
	 * Re-apply the Change.
	 */
	redo(): UnDo;
}

/**
 * Specialization of ReDo for Edit type Changes.
 */
export interface ReDoWithOrig extends ReDo {
	readonly original: any;
}

/**
 * Change describes an operation that could be applied to bring the lhs of an operation into equality with the rhs.
 */
export interface Change {
	readonly op: string;
	readonly path: PathSegment[];

	/**
	 * Apply the Change operation to a target (typically the lhs of a difference generation between two object graphs.
	 */
	apply(target: any, materialize?: boolean): UnDo;
}

/**
 * Add a value to a target object graph.
 */
export class AddToLhs implements Change {
	public readonly op: string;

	public constructor(public readonly path: PathSegment[], public readonly value: any) {
		this.op = 'A';
	}

	/**
	 * Add this objects 'value' to the specified object graph.
	 * @param target    The root of the object graph
	 * @param materialize  If materialize is truthy and the full path does not exist, missing containers will be created on the fly.
	 * WARNING!!! undo will remove the value from the previousValue target, BUT will *not* remove any "materialized" containers.
	 */
	apply(target: any, materialize?: boolean): UnDo {
		let redoFn;
		// Array's containers behave different than object, map, and set.  Specifically in order to delete, we have to splice.  That means that to undo a delete we have to splice back in (as opposed to just set).
		// Make a copy of the path so that we can flip the last segment negative, which is a Magic signal to @see setContainerElement to splice instead of assign.
		let path = this.path;
		if (path[path.length-1].typeOf === 'array') {
			path = this.path.map(seg => {
				return <PathSegment>{
					typeOf: seg.typeOf,
					segment: seg.segment
				};
			});
		}
		redoFn = () => {
			setContainerElement(target, path, this.value, materialize);
			return <UnDo>{
				undo: () => {
					deleteContainerElement(target, path);
					// Ensure that subsequent redo operations splice
					if (path[path.length-1].typeOf === 'array')
						if (<number>path[path.length-1].segment >= 0)   // This may be a redo, OR it may be that the *original* apply action is a slice, either way, don't negate more than once.
							path[path.length-1].segment = -<number>path[path.length-1].segment - 1;
					return <ReDoWithOrig>{
						original: this.value,
						redo: redoFn
					};
				}
			};
		};
		return redoFn();
	}
}

/**
 * Remove a value from a target object graph.
 */
export class RemoveFromLhs implements Change {
	public readonly op: string;

	public constructor(public readonly path: PathSegment[]) {
		this.op = 'R';
	}

	/**
	 * Remove the value at path in the specified object graph.
	 */
	apply(target: any): UnDoWithPrev {
		let redoFn;
		// @see AddToLhs.apply for explanation as to why we are making a copy of the path.
		let path = this.path;
		if (path[path.length-1].typeOf === 'array') {
			path = this.path.map(seg => {
				return <PathSegment>{
					typeOf: seg.typeOf,
					segment: seg.segment
				};
			});
		}
		redoFn = () => {
			let value = deleteContainerElement(target, path);
			return <UnDoWithPrev>{
				previousValue: value,
				undo: () => {
					// @see AddToLhs.apply for explanation as to why we are altering the path
					if (path[path.length-1].typeOf === 'array')
						if (<number>path[path.length-1].segment >= 0)
							path[path.length-1].segment = -<number>path[path.length-1].segment - 1;
					setContainerElement(target, path, value);
					return <ReDo>{
						redo: redoFn
					};
				}
			};
		};
		return redoFn();
	}
}

/**
 * Set or restore a value in a target object graph.
 */
export class EditLhs implements Change {
	public readonly op: string;

	public constructor(public readonly path: PathSegment[], public readonly value: any) {
		this.op = 'E';
	}

	/**
	 * Set this objects 'value' within the specified object graph.
	 * @param target    The root of the object graph
	 * @param materialize  If materialize is truthy and the full path does not exist, missing containers will be created on the fly.
	 * WARNING!!! undo will remove the value from the previousValue target, BUT will *not* remove any "materialized" containers.
	 */
	apply(target: any, materialize?: boolean): UnDoWithPrev {
		let redoFn;
		redoFn = () => {
			let value = this.path.length > 0 ? setContainerElement(target, this.path, this.value, materialize) : target;
			return <UnDoWithPrev>{
				previousValue: value,
				undo: () => {
					setContainerElement(target, this.path, value);
					return <ReDoWithOrig>{
						original: this.value,
						redo: redoFn
					};
				}
			};
		};
		return redoFn();
	}
}

/**
 * Stringify a list of Changes.
 * NOTE:
 *  If there are ES6 constructs in the list of Changes, the result may not be pure JSON.
 *  If there are no ES6 artifacts, the result should be pure JSON.
 *  Regardless, it *will* be able to be read with @see loadChangesFromExJson.
 */
export function writeChangesToExJson(changes: Change[]): string {
	return JSON.stringify(changes, jsonES6Replacer);
}

/**
 * Read in a list of Changes previously written by @writeChangesToExJson.
 */
export function loadChangesFromExJson(json: string) {
	return JSON.parse(json, jsonES6Reviver);
}
